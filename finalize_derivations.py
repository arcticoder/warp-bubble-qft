#!/usr/bin/env python3
"""Finalize derivations + small plots for manuscript packaging.

Produces:
- A TeX fragment with key equations and parameter definitions
- A small plot scaffold for QI-vs-mu trend (requires input JSON from an integration run)

This is meant to be lightweight and reproducible.

Usage:
  python finalize_derivations.py --results-dir results/final_integration --integration-json results/final_integration/full_integration_XXXX.json
"""

from __future__ import annotations

import argparse
import json
from datetime import datetime
from pathlib import Path
from typing import Any, Dict, Optional

import numpy as np


def _timestamp() -> str:
    return datetime.now().strftime("%Y%m%d_%H%M%S")


def _json_safe(obj: Any) -> Any:
    if isinstance(obj, (str, int, float, bool)) or obj is None:
        return obj
    if isinstance(obj, Path):
        return str(obj)
    if isinstance(obj, dict):
        return {str(k): _json_safe(v) for k, v in obj.items()}
    if isinstance(obj, (list, tuple)):
        return [_json_safe(v) for v in obj]
    if isinstance(obj, np.ndarray):
        return obj.tolist()
    if isinstance(obj, (np.floating, np.integer)):
        return obj.item()
    return str(obj)


def write_tex_fragment(out_dir: Path) -> Path:
    tex = r"""% Auto-generated by finalize_derivations.py
% TeX fragment for manuscript appendices (heuristic models clearly labeled)

\section{Enhancement Combination Model (Heuristic)}

We report enhancement factors $F_i$ (cavity, squeezing, multi-bubble) from the pipeline.
Under an independence assumption, the combined effective factor is
\[
  \eta = \prod_i F_i.
\]

Optionally, a synergy correction can be reported as a heuristic parameterization:
\[
  \eta_{\mathrm{eff}} = \eta(1+S),\qquad S = \sum_{i<j} \gamma_{ij}.
\]

A corresponding effective energy-density scaling can be written (heuristically) as
\[
  \rho_{\mathrm{eff}} = \rho_0 \prod_i \frac{1}{F_i}\,\exp\!\left(\sum_{i<j} \gamma_{ij}\right).
\]

\paragraph{Notes.}
These are reporting models used for computational bookkeeping; they are not derived
from first-principles QFT on a warp background.
"""

    out_path = out_dir / "final_derivations_fragment.tex"
    out_path.write_text(tex, encoding="utf-8")
    return out_path


def plot_qi_vs_mu(integration_json: Path, out_dir: Path) -> Optional[Path]:
    try:
        import matplotlib.pyplot as plt
    except Exception:
        return None

    data = json.loads(integration_json.read_text(encoding="utf-8"))
    runs = data.get("runs", [])

    mus = []
    deltas = []

    for r in runs:
        qi = (r.get("toy_qi_3d") or {}).get("qi")
        if not qi:
            continue
        mu = float(((r.get("inputs") or {}).get("mu")) if (r.get("inputs") or {}).get("mu") is not None else np.nan)
        margin = float(((qi.get("curved") or {}).get("margin")) if (qi.get("curved") or {}).get("margin") is not None else np.nan)
        bound = float(((qi.get("curved") or {}).get("bound")) if (qi.get("curved") or {}).get("bound") is not None else np.nan)
        if not np.isfinite(mu) or not np.isfinite(margin) or not np.isfinite(bound) or abs(bound) < 1e-12:
            continue
        # Normalized delta: (I - B)/|B|
        delta = margin / abs(bound)
        mus.append(mu)
        deltas.append(delta)

    if not mus:
        return None

    mus_arr = np.array(mus)
    deltas_arr = np.array(deltas)

    fig, ax = plt.subplots(figsize=(7, 4))
    ax.scatter(mus_arr, deltas_arr, s=18, alpha=0.8)
    ax.axhline(0.0, color="k", linewidth=1.0, alpha=0.6)
    ax.set_xlabel("mu")
    ax.set_ylabel("normalized QI delta (I - B)/|B|")
    ax.set_title("Toy curved QI delta vs mu")
    ax.grid(True, alpha=0.25)

    out_path = out_dir / "qi_delta_vs_mu.png"
    fig.tight_layout()
    fig.savefig(out_path, dpi=160)
    plt.close(fig)

    return out_path


def main() -> int:
    p = argparse.ArgumentParser(description=__doc__, formatter_class=argparse.RawDescriptionHelpFormatter)
    p.add_argument("--results-dir", type=str, default="results")
    p.add_argument("--integration-json", type=str, default=None, help="Path to full_integration_*.json (optional)")
    p.add_argument("--save-report", action="store_true")
    args = p.parse_args()

    out_dir = Path(args.results_dir)
    out_dir.mkdir(parents=True, exist_ok=True)

    tex_path = write_tex_fragment(out_dir)

    plot_path = None
    integration_json: Optional[Path] = Path(args.integration_json) if args.integration_json else None
    if integration_json is None:
        # Auto-detect newest integration artifact in the output directory.
        candidates = sorted(out_dir.glob("full_integration_*.json"), key=lambda p: p.stat().st_mtime)
        if candidates:
            integration_json = candidates[-1]

    if integration_json:
        plot_path = plot_qi_vs_mu(integration_json, out_dir)

    report: Dict[str, Any] = {
        "timestamp": _timestamp(),
        "outputs": {
            "tex_fragment": str(tex_path),
            "qi_plot": str(plot_path) if plot_path else None,
        },
        "notes": "TeX is a manuscript fragment; QI plot uses toy normalized delta from integration JSON if present.",
    }

    if args.save_report:
        out_path = out_dir / f"finalize_derivations_{report['timestamp']}.json"
        out_path.write_text(json.dumps(_json_safe(report), indent=2), encoding="utf-8")
        print(f"Wrote {out_path}")

    print(f"Wrote {tex_path}")
    if plot_path:
        print(f"Wrote {plot_path}")

    return 0


if __name__ == "__main__":
    raise SystemExit(main())
