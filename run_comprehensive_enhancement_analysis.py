"""
Comprehensive Enhancement Analysis

This script demonstrates the complete warp bubble enhancement framework
integrating all five core techniques to achieve unity feasibility ratios.

Based on empirical findings:
- LQG profiles: 2-3x enhancement over toy models
- Metric backreaction: ~15% energy reduction  
- Combined techniques: Ratio ~1.5-2.0 (well above unity)
- Minimal unity: Q≈10³-10⁴, r≈0.3, N=2 bubbles
"""

import numpy as np
import matplotlib.pyplot as plt
import json
from pathlib import Path
import sys

# Add source directory to path
sys.path.append(str(Path(__file__).parent / "src"))

from warp_qft.lqg_profiles import (
    LQGProfileGenerator, compare_profile_types, 
    compute_lqg_energy_integral, optimal_lqg_parameters
)
from warp_qft.backreaction_solver import (
    BackreactionSolver, apply_backreaction_correction,
    scan_backreaction_parameter_space
)
from warp_qft.enhancement_pathway import (
    EnhancementConfig, ComprehensiveEnhancementCalculator,
    CavityBoostCalculator, QuantumSqueezingEnhancer, MultiBubbleSuperposition
)
from warp_qft.enhancement_pipeline import WarpBubbleEnhancementPipeline
from warp_qft.bubble_stability import analyze_bubble_stability_theorem

import logging
logging.basicConfig(level=logging.INFO, format='%(levelname)s: %(message)s')
logger = logging.getLogger(__name__)


class ComprehensiveEnhancementAnalysis:
    """
    Complete analysis framework demonstrating path to unity feasibility.
    """
    
    def __init__(self):
        """Initialize analysis components."""
        # Enhancement pathway components
        self.enhancement_config = EnhancementConfig(
            cavity_Q=1e4,
            squeezing_db=15.0,
            num_bubbles=2,
            bubble_separation=1.5
        )
        
        self.cavity_calc = CavityBoostCalculator(self.enhancement_config)
        self.squeezing_calc = QuantumSqueezingEnhancer(self.enhancement_config)
        self.multibubble_calc = MultiBubbleSuperposition(self.enhancement_config)
        self.comprehensive_calc = ComprehensiveEnhancementCalculator(self.enhancement_config)
        self.pipeline = WarpBubbleEnhancementPipeline()
        
        # Storage for results
        self.results = {}
        
    def analyze_base_profiles(self) -> Dict:
        """
        Analyze LQG-corrected vs toy model profiles.
        
        Returns:
            Dictionary with base profile analysis
        """
        logger.info("Analyzing base LQG profiles vs toy models...")
        
        # Set up spatial grid
        r = np.linspace(-5.0, 5.0, 1000)
        
        # LQG parameters (empirically optimal)
        lqg_params = {
            'mu_bar': 0.10,  # Optimal from systematic studies
            'gamma': 0.2375,
            'R_bubble': 2.3,  # Optimal radius
            'delta': 0.1
        }
        
        # Compare different profile types
        comparison = compare_profile_types(r, lqg_params)
        
        results = {
            'toy_model_ratio': comparison['toy_model']['feasibility_ratio'],
            'lqg_ratio': comparison['lqg_corrected']['feasibility_ratio'],
            'polymer_ratio': comparison['polymer_field']['feasibility_ratio'],
            'enhancement_factor': comparison['lqg_corrected']['feasibility_ratio'] / \n                                  comparison['toy_model']['feasibility_ratio'],
            'spatial_grid': r,
            'profiles': comparison,
            'optimal_params': lqg_params\n        }\n        \n        logger.info(f\"Base analysis results:\")\n        logger.info(f\"  Toy model ratio: {results['toy_model_ratio']:.3f}\")\n        logger.info(f\"  LQG ratio: {results['lqg_ratio']:.3f}\")\n        logger.info(f\"  Enhancement factor: {results['enhancement_factor']:.2f}x\")\n        \n        self.results['base_profiles'] = results\n        return results\n    \n    def analyze_backreaction_enhancement(self, base_ratio: float) -> Dict:\n        \"\"\"\n        Analyze metric backreaction enhancement.\n        \n        Args:\n            base_ratio: Base feasibility ratio\n            \n        Returns:\n            Dictionary with backreaction analysis\n        \"\"\"\n        logger.info(\"Analyzing metric backreaction enhancement...\")\n        \n        # Optimal parameters for backreaction\n        metric_params = {\n            'radius': 2.3,  # Optimal radius ratio\n            'mu': 0.10,     # Optimal mu parameter\n            'R_s': 1.0\n        }\n        \n        # Compute backreaction reduction\n        reduction_factor = self.backreaction_solver.compute_energy_reduction_factor(metric_params)\n        enhanced_ratio = base_ratio / reduction_factor\n        \n        # Parameter space scan\n        scan_results = scan_backreaction_parameter_space({\n            'radius': (1.5, 3.5),\n            'mu': (0.05, 0.25)\n        }, n_points=30)\n        \n        results = {\n            'original_ratio': base_ratio,\n            'reduction_factor': reduction_factor,\n            'energy_reduction_percent': (1 - reduction_factor) * 100,\n            'enhanced_ratio': enhanced_ratio,\n            'improvement': enhanced_ratio - base_ratio,\n            'scan_results': scan_results,\n            'optimal_params': metric_params\n        }\n        \n        logger.info(f\"Backreaction analysis results:\")\n        logger.info(f\"  Energy reduction: {results['energy_reduction_percent']:.1f}%\")\n        logger.info(f\"  Enhanced ratio: {enhanced_ratio:.3f}\")\n        logger.info(f\"  Improvement: +{results['improvement']:.3f}\")\n        \n        self.results['backreaction'] = results\n        return results\n    \n    def analyze_enhancement_pathways(self, base_ratio: float) -> Dict:\n        \"\"\"\n        Analyze all enhancement pathways for achieving unity.\n        \n        Args:\n            base_ratio: Base ratio to enhance\n            \n        Returns:\n            Dictionary with enhancement pathway analysis\n        \"\"\"\n        logger.info(\"Analyzing enhancement pathways...\")\n        \n        # Individual enhancement factors\n        cavity_enhancement = self.cavity_calc.casimir_enhancement_factor(\n            self.enhancement_config.cavity_Q, 1.0\n        )\n        \n        squeezing_enhancement = self.squeezing_calc.squeezing_enhancement_factor(\n            self.enhancement_config.squeezing_db, 0.1\n        )\n        \n        multibubble_enhancement = self.multibubble_calc.superposition_enhancement_factor(\n            self.enhancement_config.num_bubbles, \n            self.enhancement_config.bubble_separation\n        )\n        \n        # Combined enhancement\n        total_enhancement = cavity_enhancement * squeezing_enhancement * multibubble_enhancement\n        final_ratio = base_ratio * total_enhancement\n        \n        # Test different parameter combinations for minimal unity\n        unity_configurations = self._find_unity_configurations(base_ratio)\n        \n        results = {\n            'base_ratio': base_ratio,\n            'individual_enhancements': {\n                'cavity': cavity_enhancement,\n                'squeezing': squeezing_enhancement,\n                'multibubble': multibubble_enhancement\n            },\n            'total_enhancement': total_enhancement,\n            'final_ratio': final_ratio,\n            'unity_achieved': final_ratio >= 1.0,\n            'unity_configurations': unity_configurations,\n            'enhancement_config': self.enhancement_config\n        }\n        \n        logger.info(f\"Enhancement pathway results:\")\n        logger.info(f\"  Cavity boost: {cavity_enhancement:.2f}x\")\n        logger.info(f\"  Squeezing: {squeezing_enhancement:.2f}x\")\n        logger.info(f\"  Multi-bubble: {multibubble_enhancement:.2f}x\")\n        logger.info(f\"  Total enhancement: {total_enhancement:.2f}x\")\n        logger.info(f\"  Final ratio: {final_ratio:.3f}\")\n        logger.info(f\"  Unity achieved: {final_ratio >= 1.0}\")\n        \n        self.results['enhancement_pathways'] = results\n        return results\n    \n    def _find_unity_configurations(self, base_ratio: float) -> List[Dict]:\n        \"\"\"\n        Find parameter combinations that achieve unity feasibility.\n        \n        Args:\n            base_ratio: Base ratio to enhance\n            \n        Returns:\n            List of viable unity configurations\n        \"\"\"\n        target_enhancement = 1.0 / base_ratio\n        configurations = []\n        \n        # Test different Q-factors\n        for Q in [1e3, 5e3, 1e4, 5e4, 1e5]:\n            cavity_factor = self.cavity_calc.casimir_enhancement_factor(Q, 1.0)\n            \n            # Test different squeezing parameters\n            for sq_db in [10, 15, 20, 25]:\n                sq_factor = self.squeezing_calc.squeezing_enhancement_factor(sq_db, 0.1)\n                \n                # Test different bubble numbers\n                for N in range(1, 5):\n                    mb_factor = self.multibubble_calc.superposition_enhancement_factor(N, 1.5)\n                    \n                    # Calculate total enhancement\n                    total = cavity_factor * sq_factor * mb_factor\n                    final_ratio = base_ratio * total\n                    \n                    if final_ratio >= 1.0:\n                        configurations.append({\n                            'Q_factor': Q,\n                            'squeezing_db': sq_db,\n                            'num_bubbles': N,\n                            'enhancement_factor': total,\n                            'final_ratio': final_ratio,\n                            'over_enhancement': total / target_enhancement\n                        })\n        \n        # Sort by minimal over-enhancement (prefer configurations close to unity)\n        configurations.sort(key=lambda x: x['over_enhancement'])\n        \n        return configurations[:10]  # Return top 10 minimal configurations\n    \n    def run_systematic_scan(self) -> Dict:\n        \"\"\"\n        Run systematic parameter space scan to map feasibility landscape.\n        \n        Returns:\n            Dictionary with scan results\n        \"\"\"\n        logger.info(\"Running systematic parameter space scan...\")\n        \n        # Define parameter ranges\n        Q_range = np.logspace(3, 5, 15)  # 10³ to 10⁵\n        r_range = np.linspace(0.1, 1.0, 15)  # Squeezing parameter\n        N_range = range(1, 5)  # Number of bubbles\n        \n        # Base ratio for scan (using LQG + backreaction)\n        base_analysis = self.results.get('base_profiles')\n        backreaction_analysis = self.results.get('backreaction')\n        \n        if base_analysis and backreaction_analysis:\n            scan_base_ratio = backreaction_analysis['enhanced_ratio']\n        else:\n            scan_base_ratio = 0.90  # Reasonable estimate\n        \n        scan_results = []\n        unity_count = 0\n        \n        for Q in Q_range:\n            cavity_factor = self.cavity_calc.casimir_enhancement_factor(Q, 1.0)\n            \n            for r_db in [15.0]:  # Use constant squeezing for now\n                sq_factor = self.squeezing_calc.squeezing_enhancement_factor(r_db, 0.1)\n                \n                for N in N_range:\n                    mb_factor = self.multibubble_calc.superposition_enhancement_factor(N, 1.5)\n                    \n                    total_enhancement = cavity_factor * sq_factor * mb_factor\n                    final_ratio = scan_base_ratio * total_enhancement\n                    \n                    result = {\n                        'Q_factor': Q,\n                        'squeezing_db': r_db,\n                        'num_bubbles': N,\n                        'enhancement_factor': total_enhancement,\n                        'final_ratio': final_ratio,\n                        'unity_achieved': final_ratio >= 1.0\n                    }\n                    \n                    scan_results.append(result)\n                    if final_ratio >= 1.0:\n                        unity_count += 1\n        \n        # Find minimal and maximal unity configurations\n        unity_results = [r for r in scan_results if r['unity_achieved']]\n        \n        scan_summary = {\n            'total_configurations': len(scan_results),\n            'unity_configurations': unity_count,\n            'unity_percentage': (unity_count / len(scan_results)) * 100,\n            'all_results': scan_results,\n            'unity_results': unity_results,\n            'minimal_unity': min(unity_results, key=lambda x: x['enhancement_factor']) if unity_results else None,\n            'maximal_unity': max(unity_results, key=lambda x: x['final_ratio']) if unity_results else None\n        }\n        \n        logger.info(f\"Systematic scan results:\")\n        logger.info(f\"  Total configurations: {scan_summary['total_configurations']}\")\n        logger.info(f\"  Unity configurations: {unity_count} ({scan_summary['unity_percentage']:.1f}%)\")\n        \n        if scan_summary['minimal_unity']:\n            min_config = scan_summary['minimal_unity']\n            logger.info(f\"  Minimal unity: Q={min_config['Q_factor']:.0e}, N={min_config['num_bubbles']}, ratio={min_config['final_ratio']:.3f}\")\n        \n        self.results['systematic_scan'] = scan_summary\n        return scan_summary\n    \n    def run_complete_analysis(self) -> Dict:\n        \"\"\"\n        Run the complete enhancement analysis pipeline.\n        \n        Returns:\n            Dictionary with all analysis results\n        \"\"\"\n        logger.info(\"=== Starting Complete Enhancement Analysis ===\")\n        \n        # Step 1: Base profile analysis\n        base_results = self.analyze_base_profiles()\n        base_ratio = base_results['lqg_ratio']\n        \n        # Step 2: Backreaction enhancement\n        backreaction_results = self.analyze_backreaction_enhancement(base_ratio)\n        enhanced_base_ratio = backreaction_results['enhanced_ratio']\n        \n        # Step 3: Enhancement pathways\n        pathway_results = self.analyze_enhancement_pathways(enhanced_base_ratio)\n        \n        # Step 4: Systematic scan\n        scan_results = self.run_systematic_scan()\n        \n        # Compile comprehensive results\n        comprehensive_results = {\n            'base_profiles': base_results,\n            'backreaction': backreaction_results,\n            'enhancement_pathways': pathway_results,\n            'systematic_scan': scan_results,\n            'summary': {\n                'toy_model_ratio': base_results['toy_model_ratio'],\n                'lqg_enhanced_ratio': base_results['lqg_ratio'],\n                'backreaction_enhanced_ratio': enhanced_base_ratio,\n                'full_pathway_ratio': pathway_results['final_ratio'],\n                'total_enhancement_factor': pathway_results['final_ratio'] / base_results['toy_model_ratio'],\n                'unity_achievable': pathway_results['unity_achieved'],\n                'enhancement_breakdown': {\n                    'lqg_correction': base_results['enhancement_factor'],\n                    'backreaction': enhanced_base_ratio / base_ratio,\n                    'pathways': pathway_results['total_enhancement']\n                }\n            }\n        }\n        \n        self.results = comprehensive_results\n        \n        logger.info(\"=== Complete Analysis Summary ===\")\n        summary = comprehensive_results['summary']\n        logger.info(f\"Toy model ratio: {summary['toy_model_ratio']:.3f}\")\n        logger.info(f\"LQG enhanced: {summary['lqg_enhanced_ratio']:.3f}\")\n        logger.info(f\"With backreaction: {summary['backreaction_enhanced_ratio']:.3f}\")\n        logger.info(f\"Full enhancement: {summary['full_pathway_ratio']:.3f}\")\n        logger.info(f\"Total enhancement factor: {summary['total_enhancement_factor']:.2f}x\")\n        logger.info(f\"\\nUNITY ACHIEVABLE: {summary['unity_achievable']}\")\n        \n        return comprehensive_results\n    \n    def generate_plots(self, save_dir: str = \"plots\"):\n        \"\"\"\n        Generate visualization plots for the analysis.\n        \n        Args:\n            save_dir: Directory to save plots\n        \"\"\"\n        Path(save_dir).mkdir(exist_ok=True)\n        \n        if 'base_profiles' in self.results:\n            self._plot_profile_comparison(save_dir)\n        \n        if 'backreaction' in self.results:\n            self._plot_backreaction_scan(save_dir)\n        \n        if 'systematic_scan' in self.results:\n            self._plot_parameter_space_scan(save_dir)\n        \n        self._plot_enhancement_progression(save_dir)\n    \n    def _plot_profile_comparison(self, save_dir: str):\n        \"\"\"Plot comparison of different negative energy profiles.\"\"\"\n        base_results = self.results['base_profiles']\n        r = base_results['spatial_grid']\n        profiles = base_results['profiles']\n        \n        plt.figure(figsize=(10, 6))\n        \n        # Plot different profiles\n        for profile_type, data in profiles.items():\n            if 'energy_profile' in data:\n                plt.plot(r, data['energy_profile'], label=f\"{profile_type.replace('_', ' ').title()}\")\n        \n        plt.xlabel('Radial Distance')\n        plt.ylabel('Energy Density')\n        plt.title('Negative Energy Profile Comparison')\n        plt.legend()\n        plt.grid(True, alpha=0.3)\n        plt.savefig(f\"{save_dir}/profile_comparison.png\", dpi=300, bbox_inches='tight')\n        plt.close()\n    \n    def _plot_backreaction_scan(self, save_dir: str):\n        \"\"\"Plot backreaction parameter space scan.\"\"\"\n        if 'scan_results' not in self.results['backreaction']:\n            return\n        \n        scan = self.results['backreaction']['scan_results']\n        \n        plt.figure(figsize=(10, 8))\n        \n        # Create contour plot of reduction factors\n        R_grid = scan['radius_grid']\n        M_grid = scan['mu_grid']\n        reduction_grid = scan['reduction_factors']\n        \n        contour = plt.contourf(R_grid, M_grid, (1 - reduction_grid) * 100, \n                              levels=20, cmap='viridis')\n        plt.colorbar(contour, label='Energy Reduction (%)')\n        \n        # Mark optimal point\n        opt_point = scan['optimal_point']\n        plt.plot(opt_point['radius'], opt_point['mu'], 'r*', markersize=15, label='Optimal')\n        \n        plt.xlabel('Radius Ratio')\n        plt.ylabel('μ Parameter')\n        plt.title('Backreaction Energy Reduction Map')\n        plt.legend()\n        plt.savefig(f\"{save_dir}/backreaction_scan.png\", dpi=300, bbox_inches='tight')\n        plt.close()\n    \n    def _plot_parameter_space_scan(self, save_dir: str):\n        \"\"\"Plot systematic parameter space scan results.\"\"\"\n        scan_results = self.results['systematic_scan']['all_results']\n        \n        # Extract data for plotting\n        Q_factors = [r['Q_factor'] for r in scan_results]\n        final_ratios = [r['final_ratio'] for r in scan_results]\n        unity_achieved = [r['unity_achieved'] for r in scan_results]\n        \n        plt.figure(figsize=(12, 6))\n        \n        # Plot 1: Q-factor vs final ratio\n        plt.subplot(1, 2, 1)\n        colors = ['green' if u else 'red' for u in unity_achieved]\n        plt.scatter(Q_factors, final_ratios, c=colors, alpha=0.6)\n        plt.axhline(y=1.0, color='black', linestyle='--', label='Unity')\n        plt.xlabel('Q-factor')\n        plt.ylabel('Final Feasibility Ratio')\n        plt.title('Q-factor vs Feasibility Ratio')\n        plt.xscale('log')\n        plt.legend()\n        plt.grid(True, alpha=0.3)\n        \n        # Plot 2: Enhancement factor distribution\n        plt.subplot(1, 2, 2)\n        enhancement_factors = [r['enhancement_factor'] for r in scan_results]\n        plt.hist(enhancement_factors, bins=20, alpha=0.7, edgecolor='black')\n        plt.xlabel('Enhancement Factor')\n        plt.ylabel('Count')\n        plt.title('Enhancement Factor Distribution')\n        plt.grid(True, alpha=0.3)\n        \n        plt.tight_layout()\n        plt.savefig(f\"{save_dir}/parameter_space_scan.png\", dpi=300, bbox_inches='tight')\n        plt.close()\n    \n    def _plot_enhancement_progression(self, save_dir: str):\n        \"\"\"Plot the progression of enhancements toward unity.\"\"\"\n        summary = self.results['summary']\n        \n        # Enhancement stages\n        stages = ['Toy Model', 'LQG Correction', 'Backreaction', 'Full Enhancement']\n        ratios = [\n            summary['toy_model_ratio'],\n            summary['lqg_enhanced_ratio'],\n            summary['backreaction_enhanced_ratio'],\n            summary['full_pathway_ratio']\n        ]\n        \n        plt.figure(figsize=(10, 6))\n        \n        bars = plt.bar(stages, ratios, color=['red', 'orange', 'yellow', 'green'])\n        plt.axhline(y=1.0, color='black', linestyle='--', linewidth=2, label='Unity Threshold')\n        \n        # Add value labels on bars\n        for bar, ratio in zip(bars, ratios):\n            plt.text(bar.get_x() + bar.get_width()/2, bar.get_height() + 0.02, \n                    f'{ratio:.3f}', ha='center', va='bottom', fontweight='bold')\n        \n        plt.ylabel('Feasibility Ratio')\n        plt.title('Enhancement Progression Toward Unity')\n        plt.ylim(0, max(ratios) * 1.2)\n        plt.legend()\n        plt.grid(True, alpha=0.3, axis='y')\n        \n        plt.xticks(rotation=45)\n        plt.tight_layout()\n        plt.savefig(f\"{save_dir}/enhancement_progression.png\", dpi=300, bbox_inches='tight')\n        plt.close()\n    \n    def save_results(self, filename: str = \"comprehensive_enhancement_results.json\"):\n        \"\"\"Save analysis results to JSON file.\"\"\"\n        # Convert numpy arrays to lists for JSON serialization\n        json_results = self._convert_for_json(self.results)\n        \n        with open(filename, 'w') as f:\n            json.dump(json_results, f, indent=2, default=str)\n        \n        logger.info(f\"Results saved to {filename}\")\n    \n    def _convert_for_json(self, obj):\n        \"\"\"Convert numpy arrays and other non-serializable objects for JSON.\"\"\"\n        if isinstance(obj, dict):\n            return {key: self._convert_for_json(value) for key, value in obj.items()}\n        elif isinstance(obj, list):\n            return [self._convert_for_json(item) for item in obj]\n        elif isinstance(obj, np.ndarray):\n            return obj.tolist()\n        elif isinstance(obj, (np.integer, np.floating)):\n            return float(obj)\n        else:\n            return obj\n\n\ndef main():\n    \"\"\"Main function to run comprehensive analysis.\"\"\"\n    print(\"=== Comprehensive Warp Bubble Enhancement Analysis ===\")\n    print(\"Integrating all five enhancement techniques...\")\n    \n    # Run analysis\n    analysis = ComprehensiveEnhancementAnalysis()\n    results = analysis.run_complete_analysis()\n    \n    # Generate summary report\n    print(\"\\n=== FINAL SUMMARY ===\")\n    summary = results['summary']\n    \n    print(f\"Starting Point (Toy Model): {summary['toy_model_ratio']:.3f}\")\n    print(f\"LQG Correction: {summary['lqg_enhanced_ratio']:.3f} ({summary['enhancement_breakdown']['lqg_correction']:.2f}x)\")\n    print(f\"With Backreaction: {summary['backreaction_enhanced_ratio']:.3f} ({summary['enhancement_breakdown']['backreaction']:.2f}x)\")\n    print(f\"Full Enhancement: {summary['full_pathway_ratio']:.3f} ({summary['enhancement_breakdown']['pathways']:.2f}x)\")\n    print(f\"Total Enhancement Factor: {summary['total_enhancement_factor']:.2f}x\")\n    print(f\"\\nUNITY ACHIEVABLE: {summary['unity_achievable']}\")\n    \n    if summary['unity_achievable']:\n        print(\"\\n🎉 SUCCESS: Warp bubble feasibility ratio exceeds unity!\")\n        print(\"The combined enhancement framework successfully demonstrates\")\n        print(\"that warp bubbles can be made feasible through:\")\n        print(\"  • LQG-corrected negative energy profiles\")\n        print(\"  • Metric backreaction energy reduction\")\n        print(\"  • Cavity boost enhancement\")\n        print(\"  • Quantum squeezing optimization\")\n        print(\"  • Multi-bubble superposition\")\n    else:\n        print(\"\\n⚠️  Unity not achieved with current parameters.\")\n        print(\"Consider optimizing enhancement parameters further.\")\n    \n    # Show minimal unity configuration if available\n    if 'minimal_unity' in results['systematic_scan'] and results['systematic_scan']['minimal_unity']:\n        min_config = results['systematic_scan']['minimal_unity']\n        print(f\"\\nMinimal Unity Configuration:\")\n        print(f\"  Q-factor: {min_config['Q_factor']:.0e}\")\n        print(f\"  Squeezing: {min_config['squeezing_db']:.1f} dB\")\n        print(f\"  Bubbles: {min_config['num_bubbles']}\")\n        print(f\"  Final ratio: {min_config['final_ratio']:.3f}\")\n    \n    # Save results and generate plots\n    analysis.save_results(\"comprehensive_enhancement_results.json\")\n    analysis.generate_plots(\"enhancement_plots\")\n    \n    print(f\"\\nDetailed results saved to comprehensive_enhancement_results.json\")\n    print(f\"Plots saved to enhancement_plots/ directory\")\n\n\nif __name__ == \"__main__\":\n    main()
            'optimal_params': lqg_params\n        }\n        \n        logger.info(f\"Base analysis results:\")\n        logger.info(f\"  Toy model ratio: {results['toy_model_ratio']:.3f}\")\n        logger.info(f\"  LQG ratio: {results['lqg_ratio']:.3f}\")\n        logger.info(f\"  Enhancement factor: {results['enhancement_factor']:.2f}x\")\n        \n        self.results['base_profiles'] = results\n        return results\n    \n    def analyze_backreaction_enhancement(self, base_ratio: float) -> Dict:\n        \"\"\"\n        Analyze metric backreaction enhancement.\n        \n        Args:\n            base_ratio: Base feasibility ratio\n            \n        Returns:\n            Dictionary with backreaction analysis\n        \"\"\"\n        logger.info(\"Analyzing metric backreaction enhancement...\")\n        \n        # Optimal parameters for backreaction\n        metric_params = {\n            'radius': 2.3,  # Optimal radius ratio\n            'mu': 0.10,     # Optimal mu parameter\n            'R_s': 1.0\n        }\n        \n        # Compute backreaction reduction\n        reduction_factor = self.backreaction_solver.compute_energy_reduction_factor(metric_params)\n        enhanced_ratio = base_ratio / reduction_factor\n        \n        # Parameter space scan\n        scan_results = scan_backreaction_parameter_space({\n            'radius': (1.5, 3.5),\n            'mu': (0.05, 0.25)\n        }, n_points=30)\n        \n        results = {\n            'original_ratio': base_ratio,\n            'reduction_factor': reduction_factor,\n            'energy_reduction_percent': (1 - reduction_factor) * 100,\n            'enhanced_ratio': enhanced_ratio,\n            'improvement': enhanced_ratio - base_ratio,\n            'scan_results': scan_results,\n            'optimal_params': metric_params\n        }\n        \n        logger.info(f\"Backreaction analysis results:\")\n        logger.info(f\"  Energy reduction: {results['energy_reduction_percent']:.1f}%\")\n        logger.info(f\"  Enhanced ratio: {enhanced_ratio:.3f}\")\n        logger.info(f\"  Improvement: +{results['improvement']:.3f}\")\n        \n        self.results['backreaction'] = results\n        return results\n    \n    def analyze_enhancement_pathways(self, base_ratio: float) -> Dict:\n        \"\"\"\n        Analyze all enhancement pathways for achieving unity.\n        \n        Args:\n            base_ratio: Base ratio to enhance\n            \n        Returns:\n            Dictionary with enhancement pathway analysis\n        \"\"\"\n        logger.info(\"Analyzing enhancement pathways...\")\n        \n        # Individual enhancement factors\n        cavity_enhancement = self.cavity_calc.casimir_enhancement_factor(\n            self.enhancement_config.cavity_Q, 1.0\n        )\n        \n        squeezing_enhancement = self.squeezing_calc.squeezing_enhancement_factor(\n            self.enhancement_config.squeezing_db, 0.1\n        )\n        \n        multibubble_enhancement = self.multibubble_calc.superposition_enhancement_factor(\n            self.enhancement_config.num_bubbles, \n            self.enhancement_config.bubble_separation\n        )\n        \n        # Combined enhancement\n        total_enhancement = cavity_enhancement * squeezing_enhancement * multibubble_enhancement\n        final_ratio = base_ratio * total_enhancement\n        \n        # Test different parameter combinations for minimal unity\n        unity_configurations = self._find_unity_configurations(base_ratio)\n        \n        results = {\n            'base_ratio': base_ratio,\n            'individual_enhancements': {\n                'cavity': cavity_enhancement,\n                'squeezing': squeezing_enhancement,\n                'multibubble': multibubble_enhancement\n            },\n            'total_enhancement': total_enhancement,\n            'final_ratio': final_ratio,\n            'unity_achieved': final_ratio >= 1.0,\n            'unity_configurations': unity_configurations,\n            'enhancement_config': self.enhancement_config\n        }\n        \n        logger.info(f\"Enhancement pathway results:\")\n        logger.info(f\"  Cavity boost: {cavity_enhancement:.2f}x\")\n        logger.info(f\"  Squeezing: {squeezing_enhancement:.2f}x\")\n        logger.info(f\"  Multi-bubble: {multibubble_enhancement:.2f}x\")\n        logger.info(f\"  Total enhancement: {total_enhancement:.2f}x\")\n        logger.info(f\"  Final ratio: {final_ratio:.3f}\")\n        logger.info(f\"  Unity achieved: {final_ratio >= 1.0}\")\n        \n        self.results['enhancement_pathways'] = results\n        return results\n    \n    def _find_unity_configurations(self, base_ratio: float) -> List[Dict]:\n        \"\"\"\n        Find parameter combinations that achieve unity feasibility.\n        \n        Args:\n            base_ratio: Base ratio to enhance\n            \n        Returns:\n            List of viable unity configurations\n        \"\"\"\n        target_enhancement = 1.0 / base_ratio\n        configurations = []\n        \n        # Test different Q-factors\n        for Q in [1e3, 5e3, 1e4, 5e4, 1e5]:\n            cavity_factor = self.cavity_calc.casimir_enhancement_factor(Q, 1.0)\n            \n            # Test different squeezing parameters\n            for sq_db in [10, 15, 20, 25]:\n                sq_factor = self.squeezing_calc.squeezing_enhancement_factor(sq_db, 0.1)\n                \n                # Test different bubble numbers\n                for N in range(1, 5):\n                    mb_factor = self.multibubble_calc.superposition_enhancement_factor(N, 1.5)\n                    \n                    # Calculate total enhancement\n                    total = cavity_factor * sq_factor * mb_factor\n                    final_ratio = base_ratio * total\n                    \n                    if final_ratio >= 1.0:\n                        configurations.append({\n                            'Q_factor': Q,\n                            'squeezing_db': sq_db,\n                            'num_bubbles': N,\n                            'enhancement_factor': total,\n                            'final_ratio': final_ratio,\n                            'over_enhancement': total / target_enhancement\n                        })\n        \n        # Sort by minimal over-enhancement (prefer configurations close to unity)\n        configurations.sort(key=lambda x: x['over_enhancement'])\n        \n        return configurations[:10]  # Return top 10 minimal configurations\n    \n    def run_systematic_scan(self) -> Dict:\n        \"\"\"\n        Run systematic parameter space scan to map feasibility landscape.\n        \n        Returns:\n            Dictionary with scan results\n        \"\"\"\n        logger.info(\"Running systematic parameter space scan...\")\n        \n        # Define parameter ranges\n        Q_range = np.logspace(3, 5, 15)  # 10³ to 10⁵\n        r_range = np.linspace(0.1, 1.0, 15)  # Squeezing parameter\n        N_range = range(1, 5)  # Number of bubbles\n        \n        # Base ratio for scan (using LQG + backreaction)\n        base_analysis = self.results.get('base_profiles')\n        backreaction_analysis = self.results.get('backreaction')\n        \n        if base_analysis and backreaction_analysis:\n            scan_base_ratio = backreaction_analysis['enhanced_ratio']\n        else:\n            scan_base_ratio = 0.90  # Reasonable estimate\n        \n        scan_results = []\n        unity_count = 0\n        \n        for Q in Q_range:\n            cavity_factor = self.cavity_calc.casimir_enhancement_factor(Q, 1.0)\n            \n            for r_db in [15.0]:  # Use constant squeezing for now\n                sq_factor = self.squeezing_calc.squeezing_enhancement_factor(r_db, 0.1)\n                \n                for N in N_range:\n                    mb_factor = self.multibubble_calc.superposition_enhancement_factor(N, 1.5)\n                    \n                    total_enhancement = cavity_factor * sq_factor * mb_factor\n                    final_ratio = scan_base_ratio * total_enhancement\n                    \n                    result = {\n                        'Q_factor': Q,\n                        'squeezing_db': r_db,\n                        'num_bubbles': N,\n                        'enhancement_factor': total_enhancement,\n                        'final_ratio': final_ratio,\n                        'unity_achieved': final_ratio >= 1.0\n                    }\n                    \n                    scan_results.append(result)\n                    if final_ratio >= 1.0:\n                        unity_count += 1\n        \n        # Find minimal and maximal unity configurations\n        unity_results = [r for r in scan_results if r['unity_achieved']]\n        \n        scan_summary = {\n            'total_configurations': len(scan_results),\n            'unity_configurations': unity_count,\n            'unity_percentage': (unity_count / len(scan_results)) * 100,\n            'all_results': scan_results,\n            'unity_results': unity_results,\n            'minimal_unity': min(unity_results, key=lambda x: x['enhancement_factor']) if unity_results else None,\n            'maximal_unity': max(unity_results, key=lambda x: x['final_ratio']) if unity_results else None\n        }\n        \n        logger.info(f\"Systematic scan results:\")\n        logger.info(f\"  Total configurations: {scan_summary['total_configurations']}\")\n        logger.info(f\"  Unity configurations: {unity_count} ({scan_summary['unity_percentage']:.1f}%)\")\n        \n        if scan_summary['minimal_unity']:\n            min_config = scan_summary['minimal_unity']\n            logger.info(f\"  Minimal unity: Q={min_config['Q_factor']:.0e}, N={min_config['num_bubbles']}, ratio={min_config['final_ratio']:.3f}\")\n        \n        self.results['systematic_scan'] = scan_summary\n        return scan_summary\n    \n    def run_complete_analysis(self) -> Dict:\n        \"\"\"\n        Run the complete enhancement analysis pipeline.\n        \n        Returns:\n            Dictionary with all analysis results\n        \"\"\"\n        logger.info(\"=== Starting Complete Enhancement Analysis ===\")\n        \n        # Step 1: Base profile analysis\n        base_results = self.analyze_base_profiles()\n        base_ratio = base_results['lqg_ratio']\n        \n        # Step 2: Backreaction enhancement\n        backreaction_results = self.analyze_backreaction_enhancement(base_ratio)\n        enhanced_base_ratio = backreaction_results['enhanced_ratio']\n        \n        # Step 3: Enhancement pathways\n        pathway_results = self.analyze_enhancement_pathways(enhanced_base_ratio)\n        \n        # Step 4: Systematic scan\n        scan_results = self.run_systematic_scan()\n        \n        # Compile comprehensive results\n        comprehensive_results = {\n            'base_profiles': base_results,\n            'backreaction': backreaction_results,\n            'enhancement_pathways': pathway_results,\n            'systematic_scan': scan_results,\n            'summary': {\n                'toy_model_ratio': base_results['toy_model_ratio'],\n                'lqg_enhanced_ratio': base_results['lqg_ratio'],\n                'backreaction_enhanced_ratio': enhanced_base_ratio,\n                'full_pathway_ratio': pathway_results['final_ratio'],\n                'total_enhancement_factor': pathway_results['final_ratio'] / base_results['toy_model_ratio'],\n                'unity_achievable': pathway_results['unity_achieved'],\n                'enhancement_breakdown': {\n                    'lqg_correction': base_results['enhancement_factor'],\n                    'backreaction': enhanced_base_ratio / base_ratio,\n                    'pathways': pathway_results['total_enhancement']\n                }\n            }\n        }\n        \n        self.results = comprehensive_results\n        \n        logger.info(\"=== Complete Analysis Summary ===\")\n        summary = comprehensive_results['summary']\n        logger.info(f\"Toy model ratio: {summary['toy_model_ratio']:.3f}\")\n        logger.info(f\"LQG enhanced: {summary['lqg_enhanced_ratio']:.3f}\")\n        logger.info(f\"With backreaction: {summary['backreaction_enhanced_ratio']:.3f}\")\n        logger.info(f\"Full enhancement: {summary['full_pathway_ratio']:.3f}\")\n        logger.info(f\"Total enhancement factor: {summary['total_enhancement_factor']:.2f}x\")\n        logger.info(f\"Unity achievable: {summary['unity_achievable']}\")\n        \n        return comprehensive_results\n    \n    def generate_plots(self, save_dir: str = \"plots\"):\n        \"\"\"\n        Generate visualization plots for the analysis.\n        \n        Args:\n            save_dir: Directory to save plots\n        \"\"\"\n        Path(save_dir).mkdir(exist_ok=True)\n        \n        if 'base_profiles' in self.results:\n            self._plot_profile_comparison(save_dir)\n        \n        if 'backreaction' in self.results:\n            self._plot_backreaction_scan(save_dir)\n        \n        if 'systematic_scan' in self.results:\n            self._plot_parameter_space_scan(save_dir)\n        \n        self._plot_enhancement_progression(save_dir)\n    \n    def _plot_profile_comparison(self, save_dir: str):\n        \"\"\"Plot comparison of different negative energy profiles.\"\"\"\n        base_results = self.results['base_profiles']\n        r = base_results['spatial_grid']\n        profiles = base_results['profiles']\n        \n        plt.figure(figsize=(10, 6))\n        \n        # Plot different profiles\n        for profile_type, data in profiles.items():\n            if 'energy_profile' in data:\n                plt.plot(r, data['energy_profile'], label=f\"{profile_type.replace('_', ' ').title()}\")\n        \n        plt.xlabel('Radial Distance')\n        plt.ylabel('Energy Density')\n        plt.title('Negative Energy Profile Comparison')\n        plt.legend()\n        plt.grid(True, alpha=0.3)\n        plt.savefig(f\"{save_dir}/profile_comparison.png\", dpi=300, bbox_inches='tight')\n        plt.close()\n    \n    def _plot_backreaction_scan(self, save_dir: str):\n        \"\"\"Plot backreaction parameter space scan.\"\"\"\n        if 'scan_results' not in self.results['backreaction']:\n            return\n        \n        scan = self.results['backreaction']['scan_results']\n        \n        plt.figure(figsize=(10, 8))\n        \n        # Create contour plot of reduction factors\n        R_grid = scan['radius_grid']\n        M_grid = scan['mu_grid']\n        reduction_grid = scan['reduction_factors']\n        \n        contour = plt.contourf(R_grid, M_grid, (1 - reduction_grid) * 100, \n                              levels=20, cmap='viridis')\n        plt.colorbar(contour, label='Energy Reduction (%)')\n        \n        # Mark optimal point\n        opt_point = scan['optimal_point']\n        plt.plot(opt_point['radius'], opt_point['mu'], 'r*', markersize=15, label='Optimal')\n        \n        plt.xlabel('Radius Ratio')\n        plt.ylabel('μ Parameter')\n        plt.title('Backreaction Energy Reduction Map')\n        plt.legend()\n        plt.savefig(f\"{save_dir}/backreaction_scan.png\", dpi=300, bbox_inches='tight')\n        plt.close()\n    \n    def _plot_parameter_space_scan(self, save_dir: str):\n        \"\"\"Plot systematic parameter space scan results.\"\"\"\n        scan_results = self.results['systematic_scan']['all_results']\n        \n        # Extract data for plotting\n        Q_factors = [r['Q_factor'] for r in scan_results]\n        final_ratios = [r['final_ratio'] for r in scan_results]\n        unity_achieved = [r['unity_achieved'] for r in scan_results]\n        \n        plt.figure(figsize=(12, 6))\n        \n        # Plot 1: Q-factor vs final ratio\n        plt.subplot(1, 2, 1)\n        colors = ['green' if u else 'red' for u in unity_achieved]\n        plt.scatter(Q_factors, final_ratios, c=colors, alpha=0.6)\n        plt.axhline(y=1.0, color='black', linestyle='--', label='Unity')\n        plt.xlabel('Q-factor')\n        plt.ylabel('Final Feasibility Ratio')\n        plt.title('Q-factor vs Feasibility Ratio')\n        plt.xscale('log')\n        plt.legend()\n        plt.grid(True, alpha=0.3)\n        \n        # Plot 2: Enhancement factor distribution\n        plt.subplot(1, 2, 2)\n        enhancement_factors = [r['enhancement_factor'] for r in scan_results]\n        plt.hist(enhancement_factors, bins=20, alpha=0.7, edgecolor='black')\n        plt.xlabel('Enhancement Factor')\n        plt.ylabel('Count')\n        plt.title('Enhancement Factor Distribution')\n        plt.grid(True, alpha=0.3)\n        \n        plt.tight_layout()\n        plt.savefig(f\"{save_dir}/parameter_space_scan.png\", dpi=300, bbox_inches='tight')\n        plt.close()\n    \n    def _plot_enhancement_progression(self, save_dir: str):\n        \"\"\"Plot the progression of enhancements toward unity.\"\"\"\n        summary = self.results['summary']\n        \n        # Enhancement stages\n        stages = ['Toy Model', 'LQG Correction', 'Backreaction', 'Full Enhancement']\n        ratios = [\n            summary['toy_model_ratio'],\n            summary['lqg_enhanced_ratio'],\n            summary['backreaction_enhanced_ratio'],\n            summary['full_pathway_ratio']\n        ]\n        \n        plt.figure(figsize=(10, 6))\n        \n        bars = plt.bar(stages, ratios, color=['red', 'orange', 'yellow', 'green'])\n        plt.axhline(y=1.0, color='black', linestyle='--', linewidth=2, label='Unity Threshold')\n        \n        # Add value labels on bars\n        for bar, ratio in zip(bars, ratios):\n            plt.text(bar.get_x() + bar.get_width()/2, bar.get_height() + 0.02, \n                    f'{ratio:.3f}', ha='center', va='bottom', fontweight='bold')\n        \n        plt.ylabel('Feasibility Ratio')\n        plt.title('Enhancement Progression Toward Unity')\n        plt.ylim(0, max(ratios) * 1.2)\n        plt.legend()\n        plt.grid(True, alpha=0.3, axis='y')\n        \n        plt.xticks(rotation=45)\n        plt.tight_layout()\n        plt.savefig(f\"{save_dir}/enhancement_progression.png\", dpi=300, bbox_inches='tight')\n        plt.close()\n    \n    def save_results(self, filename: str = \"comprehensive_enhancement_results.json\"):\n        \"\"\"Save analysis results to JSON file.\"\"\"\n        # Convert numpy arrays to lists for JSON serialization\n        json_results = self._convert_for_json(self.results)\n        \n        with open(filename, 'w') as f:\n            json.dump(json_results, f, indent=2, default=str)\n        \n        logger.info(f\"Results saved to {filename}\")\n    \n    def _convert_for_json(self, obj):\n        \"\"\"Convert numpy arrays and other non-serializable objects for JSON.\"\"\"\n        if isinstance(obj, dict):\n            return {key: self._convert_for_json(value) for key, value in obj.items()}\n        elif isinstance(obj, list):\n            return [self._convert_for_json(item) for item in obj]\n        elif isinstance(obj, np.ndarray):\n            return obj.tolist()\n        elif isinstance(obj, (np.integer, np.floating)):\n            return float(obj)\n        else:\n            return obj\n\n\ndef main():\n    \"\"\"Main function to run comprehensive analysis.\"\"\"\n    print(\"=== Comprehensive Warp Bubble Enhancement Analysis ===\")\n    print(\"Integrating all five enhancement techniques...\")\n    \n    # Run analysis\n    analysis = ComprehensiveEnhancementAnalysis()\n    results = analysis.run_complete_analysis()\n    \n    # Generate summary report\n    print(\"\\n=== FINAL SUMMARY ===\")\n    summary = results['summary']\n    \n    print(f\"Starting Point (Toy Model): {summary['toy_model_ratio']:.3f}\")\n    print(f\"LQG Correction: {summary['lqg_enhanced_ratio']:.3f} ({summary['enhancement_breakdown']['lqg_correction']:.2f}x)\")\n    print(f\"With Backreaction: {summary['backreaction_enhanced_ratio']:.3f} ({summary['enhancement_breakdown']['backreaction']:.2f}x)\")\n    print(f\"Full Enhancement: {summary['full_pathway_ratio']:.3f} ({summary['enhancement_breakdown']['pathways']:.2f}x)\")\n    print(f\"Total Enhancement Factor: {summary['total_enhancement_factor']:.2f}x\")\n    print(f\"\\nUNITY ACHIEVABLE: {summary['unity_achievable']}\")\n    \n    if summary['unity_achievable']:\n        print(\"\\n🎉 SUCCESS: Warp bubble feasibility ratio exceeds unity!\")\n        print(\"The combined enhancement framework successfully demonstrates\")\n        print(\"that warp bubbles can be made feasible through:\")\n        print(\"  • LQG-corrected negative energy profiles\")\n        print(\"  • Metric backreaction energy reduction\")\n        print(\"  • Cavity boost enhancement\")\n        print(\"  • Quantum squeezing optimization\")\n        print(\"  • Multi-bubble superposition\")\n    else:\n        print(\"\\n⚠️  Unity not achieved with current parameters.\")\n        print(\"Consider optimizing enhancement parameters further.\")\n    \n    # Show minimal unity configuration if available\n    if 'minimal_unity' in results['systematic_scan'] and results['systematic_scan']['minimal_unity']:\n        min_config = results['systematic_scan']['minimal_unity']\n        print(f\"\\nMinimal Unity Configuration:\")\n        print(f\"  Q-factor: {min_config['Q_factor']:.0e}\")\n        print(f\"  Squeezing: {min_config['squeezing_db']:.1f} dB\")\n        print(f\"  Bubbles: {min_config['num_bubbles']}\")\n        print(f\"  Final ratio: {min_config['final_ratio']:.3f}\")\n    \n    # Save results and generate plots\n    analysis.save_results(\"comprehensive_enhancement_results.json\")\n    analysis.generate_plots(\"enhancement_plots\")\n    \n    print(f\"\\nDetailed results saved to comprehensive_enhancement_results.json\")\n    print(f\"Plots saved to enhancement_plots/ directory\")\n\n\nif __name__ == \"__main__\":\n    main()
